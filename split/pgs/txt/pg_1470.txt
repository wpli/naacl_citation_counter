Type-Driven Incremental Semantic Parsing with Polymorphism
Kai Zhao Graduate Center City University of New York kzhao.hf@gmail.com Abstract
Semantic parsing has made significant progress, but most current semantic parsers are extremely slow (CKY-based) and rather primitive in representation. We introduce three new techniques to tackle these problems. First, we design the first linear-time incremental shift-reduce-style semantic parsing algorithm which is more efficient than conventional cubic-time bottom-up semantic parsers. Second, our parser, being type-driven instead of syntax-driven, uses type-checking to decide the direction of reduction, which eliminates the need for a syntactic grammar such as CCG. Third, to fully exploit the power of type-driven semantic parsing beyond simple types (such as entities and truth values), we borrow from programming language theory the concepts of subtype polymorphism and parametric polymorphism to enrich the type system in order to better guide the parsing. Our system learns very accurate parses in G EO Q UERY, J OBS and ATIS domains.

Liang Huang Queens College and Graduate Center City University of New York liang.huang.sh@gmail.com
nating the need for a syntactic grammar such as CCG to explicitly encode the direction of function application. However, to fully exploit the power of type-driven incremental parsing, we need a more sophisticated type system than simply typed lambda calculus. Compare the following two phrases: (1) the governor of New York (2) the mayor of New York If we know that governor is a function from state to person, then the first New York can only be of type state; similarly knowing mayor maps city to person disambiguates the second New York to be of type city. This can not be done using a simple type system with just entities and booleans. Now let us consider a more complex question which will be our running example in this paper: (3) What is the capital of the largest state by area? Since we know capital takes a state as input, we expect the largest state by area to return a state. But does largest always return a state type? Notice that it is polymorphic, for example, largest city by population, or largest lake by perimeter. So there is no unique type for largest: its return type should depend on the type of its first argument (city, state, or lake). This observation motivates us to introduce the powerful mechanism of parametric polymorphism from programming languages into natural language semantics for the first time. For example, we can define the type of largest to be a template largest : ('at)('ai)'a where 'a is a type variable that can match any type (for formal details see §3). Just like in functional programming languages such as ML or Haskell, type variables can be bound to a real type (or a range of types) during function application, using the technique of type inference. In the above example, when largest is applied to city, we know that type variable 'a is bound to type city (or its subtype), so largest would eventually return a city. We make the following contributions: · We design the first linear-time incremental semantic parsing algorithm (§2), which is much more efficient than the existing semantic parsers that are cubictime and CKY-based.

1

Introduction

Most existing semantic parsing efforts employ a CKYstyle bottom-up parsing strategy to generate a meaning representation in simply typed lambda calculus (Zettlemoyer and Collins, 2005; Lu and Ng, 2011) or its variants (Wong and Mooney, 2007; Liang et al., 2011). Although these works led to fairly accurate semantic parsers, there are two major drawbacks: efficiency and expressiveness. First, as many researches in syntactic parsing (Nivre, 2008; Zhang and Clark, 2011) have shown, compared to cubic-time CKY-style parsing, incremental parsing can achieve comparable accuracies while being linear-time, and orders of magnitude faster in practice. We therefore introduce the first incremental parsing algorithm for semantic parsing. More interestingly, unlike syntactic parsing, our incremental semantic parsing algorithm, being strictly type-driven, directly employs type checking to automatically determine the direction of function application on-the-fly, thus reducing the search space and elimiWe are also grateful to Luke Zettelmoyer, Yoav Artzi, and Tom Kwiatkowski for providing data. This research is supported by DARPA FA8750-13-2-0041 (DEFT), NSF IIS-1449278, and a Google Faculty Research Award.
We thank the reviewers for helpful suggestions.

1416
Human Language Technologies: The 2015 Annual Conference of the North American Chapter of the ACL, pages 1416­1421, Denver, Colorado, May 31 ­ June 5, 2015. c 2015 Association for Computational Linguistics

