is a finite set of non-terminals with a function dim : N  N determining the fan-out of each A  N ; T and V are disjoint finite sets of terminals and variables; S  N is the start symbol with dim (S ) = 1. P is a finite set of rewriting rules with rank m  0. All   P have the form
A(0 , . . . , dim (A)-1 )  A1 (X0 , . . . , Xdim (A1 )-1 )
(m) (m) · · · Am (X0 , . . . , Xdim (Am )-1 ) (1) (1)

 : S (xy )  A(x, y )  : A(a, b)    : A(ax, ya)  A(x, y ) Figure 1: LCFRS for {an aban | n  0}

where A, A1 , . . . , Am  N , Xj  V for 1  l  m, 0  j < dim (Ai ) and i  (V  T )+ for (l) 0  i < dim (A). All i and Xj are called arguments (or sometimes components); the elements in i are called argument elements. A is the set of all argument elements of  . Variable occurrences in the arguments of the non-terminals of  are ordered by a strict total order . For all X1 , X2  V occurring in arguments of a non-terminal of  , it holds that X1  X2 iff either X1 precedes X2 in an argument of the non-terminal or the argument X1 occurs in precedes the argument X2 occurs in. For all   P , every variable X occurring in  occurs exactly once in the left-hand side (LHS) and exactly once in the right-hand side (RHS). Furthermore, if for two variables X1 , X2  V , it holds that X1  X2 on the RHS, then also X1  X2 on the LHS. The rank of G is the maximal rank of any of its rules, its fan-out is the maximal fan-out of any of its non-terminals. We use the following additional notation: For a rule   P , lhs ( ) gives the LHS non-terminal; lhs (, i) gives the ith argument of the LHS and lhs (, i, j ) its j th symbol; rhs (, k ) gives the k th RHS non-terminal; and rhs (, k, l) gives the lth component of the k th RHS element (starting with index 0 in all four cases). These function have value  whenever there is no such element. Furthermore, in the sense of dotted productions, we define for each   P a set of symbols denoting computation points of  , C = {i.j | 0  i < dim A , 0  j  |i |}, as well as the set C =  P C . A non-terminal A  N can be instantiated w.r.t. an input string w1 · · · w|w| and a rule   P with lhs ( ) = A. An instantiation maps all argument elements of  to spans of w ((i - 1, j )w denotes the span wi · · · wj , 1  i  j  n). All instantiations are given by a function  : A  N × N where

(l)

for all x, y  A with x = y ,  (x) = (i, j )w and  (y ) = (k, l)w it holds that i, k  0; j, l  |w|; if x (y ) is a terminal, then j = i + 1 (l = k + 1), otherwise j > i (k > l). Iff x  y in  , then j  k . A derivation rewrites strings of instantiated non-terminals, i.e., given an instantiated clause, the instantiated LHS non-terminal may be replaced with the sequence of instantiated RHS terminals. The language of the grammar is the set of strings which can be reduced to the empty word, starting with S instantiated to the input string. See figure 1 for a sample LCFRS. 2.2 Thread Automata

Thread automata (TA) (Villemonte de la Clergerie, 2002) are a generic automaton model which can be parametrized to recognize different mildly contextsensitive languages. The TA for LCFRS (LCFRSTA) implements a prefix-valid top-down incremental parsing strategy similar to the ones of Kallmeyer and Maier (2009) and Burden and Ljungl¨ of (2005). An LCFRS-TA for some LCFRS G = (N, T, V, P, S ) works as follows. The processing of a single rule is handled by a single thread which will traverse the LHS arguments of the rule. A thread is given by a pair p : X , where p  {1, . . . , m} with m the rank of G is the address, and X  N  {ret}  C where ret  / N is the content of the thread. An automaton state is given by a tuple i, p, T where T is a set of threads, the thread store, p is the address of the active thread, and i  0 indicates that i tokens have been recognized. We introduce a new start symbol S  / N that expands to S and use 0, , { : S } as start state. The specific TA for a given LCFRS G = (N, T, V, P, S ) can be defined as tuple N , T, S , ret , ,  with N = N  C  {S , ret};  is a function from C to {1, . . . , m}  {} such that  (k,i ) = j if there is a l such that lhs (, k, i) = rhs (, j - 1, l), and  (k,i ) =  if lhs (, k, i)  T  {} (intuitively, a  value j tells us that the next symbol to process is a variable that

1251

