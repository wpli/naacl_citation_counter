Algorithm 1 Dynamic Programming Algorithm
Input: ZDD Z that represent T , length limit L, and wi , li for 1iN Output: Optimal subtree r 1: Initialize S [i][j ]  - for all i, j . 2: S [|Z | - 1][0]  0. 3: for i = |Z | - 2, . . . , 1 do 4: for j = 0, . . . , L do 5: if j  lv(i) and S [hi(i)][j - lv(i) ] + wv(i) > S [lo(i)][j ] then 6: S [i][j ]  S [hi(i)][j - lv(i) ] + wv(i) 7: B [i][j ]  HI 8: else 9: S [i][j ]  S [lo(i)][j ], B [i][j ]  LO 10: k  argmax0kL S [1][k] 11: i  1, j  k , r   12: while (i, j ) = (|Z | - 1, 0) do 13: if B [i][j ] = HI then 14: r  r  {v(i)}, i  hi(i), j  j - lv(i) 15: else 16: i  lo(i) 17: return r

Figure 2: An example ZDD and how the dynamic programming algorithm works with the ZDD. (a) An example ZDD that represents the family of sets {e1 e2 , e1 e3 , e2 e3 }, (b) table S and (c) table B after completion of the table filling phase. in Fig. 2(a) is 1. The ZDD has three different paths that start at the root node and end at . Each path corresponds to an item contained in the family of sets. In the following, let z1 , . . . , z|Z | be the nodes of a ZDD. We use Z to represent a ZDD, and |Z | to represent the number of nodes in Z . We assume i < hi(i), lo(i) for every i = 1, . . . , |Z | - 2. z1 corresponds to the root node, and z|Z |-1 , z|Z | corresponds to and  terminal nodes, respectively. We also assume that the ZDD is ordered, i.e., there is a total order on the labels, and the label of a parent node comes before that of a child node for every parent-child node pair. The ZDD in Fig. 2(a) is an ordered ZDD whose order is e1 , e2 , e3 .

4

Dynamic Programming Algorithm for Tree Trimming Problems

Our algorithm takes the following three-step procedure. First, we represent the set of subtrees T for each tree trimming problem as a ZDD. Then we apply a bottom-up and table-filling style DP algorithm to the ZDD. Finally, we backtrack the filled table to obtain an optimal solution. Our algorithm is similar to the standard DP algorithm for the 0-1 knapsack problem, which solves the problem in O(N L) time with N items and length limit L. The DP algorithm solves a knapsack problem by filling an N × (L +1) table by recursively exploiting previously computed partial solutions. Our algorithm also fills a table for problem solving, but the table's size is |Z | × (L + 1). That is, the size of the table equals the number of nodes of the ZDD 465

that represents a set of subtrees T . The tables can be seen as the set of |Z | arrays with (L + 1) entries, and each array is associated with each ZDD node. We fill these tables by referring to previously computed results by using the ZDD's structure. Alg. 1 is the DP algorithm that can solve the problem of Eq.(1), given the ZDD that represents the family of sets T . We first prepare two tables, S and B ; both have |Z | × (L + 1) entries. Table S is used for storing intermediate weights, and B is used for storing information used in recovering the optimal solution. We first fill the elements in S and B while traversing the ZDD in order from the terminal nodes to the root node. We then use B to recover the solution that maximizes the weight. In the table filling phase (lines 1 to 9), we update S [i][j ] and B [i][j ], recursively. Weight S [i][j ] represents the maximum weight of the ZDD path from the i-th node to the terminal node, whose total length is j . We compare S [hi(i)][j - lv(i) ] + wv(i) and S [lo(i)][j ], and select the maximum weight to set S [i][j ]. The value of B [i][j ] stores which candidate we set to S [i][j ]. If we use the former one, we set label HI to B [i][j ], otherwise LO. After filling the table, we run a backtracking procedure to obtain an optimal solution. In the backtracking phase (lines 10 to 16), we start from B [i][k  ] and repeat backtracking using the entries of B.

