of the verb phrase "be robbed by" to be the object of "the officer arrest". We can see in both examples (and for the Type 2 schema in general), that both predicates (the entity predicate and the pronoun predicate) play a crucial role. Consequently, we design the Type 2 schema to capture the interaction between the entity predicate and the pronoun predicate. In addition to the predicates, we may need mention-argument information. Also, we stress the importance of the discourse connective between entity mention and pronoun; if in either sentence 2.1 or 2.2, we change the discourse connective to "although", the coreference resolution will completely change. Overall, we can represent the knowledge as "predm (m, a) |predm (m, a) , cn". Just like for Type 1 schema, we can represent Type 2 schema with a score function for different variations of arguments (lower half of Table 3). In Table 2, we exhibit this for sentence 2.2. Type 3 contains the set of instances which cannot be solved using schemas of Type 1 or 2. Two such examples are included in Table 1. In sentence 3.1 and 3.2, the context containing the necessary information goes beyond our triple representation and therefore this instance cannot be resolved with either of the two schema types. It is important to note that the notion of Predicate Schemas is more general than the Type 1 and Type 2 schemas introduced here. Designing more informative and structured schemas will be essential to resolving additional types of hard coreference instances.

proach (Section 2.3 from Chang et al. (2011)) for inference. The ILP problem that we solve is formally defined as follows:   arg max fu,v yu,v   y   uM,v M    s.t. yu,v  {0, 1}, u, v  M  u<v,uM yu,v  1, v  M     Constraints from Predicate Schemas Knowledge     Constraints between pronouns. Here, u, v are mentions and yu,v is the decision variable to indicate whether or not mention u and mention v are coreferents. As the first constraint shows, yu,v is a binary variable. yu,v equals 1 if u, v are coreferents and 0 otherwise. The second constraint indicates that we only choose at most one antecedent to be coreferent with each mention v . (u < v represents that u appears beore v , thus u is an antecedent of v .) In this work, we add constraints from Predicate Schemas Knowledge and between pronouns. The Predicate Schemas knowledge provides a vector of score values S (u, v ) for mention pairs {(u, v )|(u  M, v  P}, which concatenates all the schemas involving u and v . Entries in the score vector are designed so that the larger the value is, the more likely u and v are to be coreferents. We have two ways to use the score values: 1) Augumenting the feature vector (u, v ) with these scores. 2) Casting the scores as constraints for the coreference resolution ILP in one of the following forms:
if si (u, v )  i si (w, v )  yu,v  yw,v , if si (u, v )  si (w, v ) + i  yu,v  yw,v , (1)

3

Constrained ILP Inference

Integer Linear Programming (ILP) based formulations of NLP problems (Roth and Yih, 2004) have been used in a board range of NLP problems and, particularly, in coreference problems (Chang et al., 2011; Denis and Baldridge, 2007). Our formulation is inspired by Chang et al. (2013). Let M be the set of all mentions in a given text snippet, and P the set of all pronouns, such that P  M. We train a coreference model by learning a pairwise mention scoring function. Specifically, given a mention-pair (u, v )  M (u is the antecedent of v ), we learn a left-linking scoring function fu,v = w (u, v ), where (u, v ) is a pairwise feature vector and w is the weight vector. We then follow the Best-Link ap812

where si (.) is the i-th dimension of the score vector S (.) corresponding to the i-th schema represented for a given mention pair. i and i are threshold values which we tune on a development set.3 If an inequality holds for all relevant schemas (that is, all the dimensions of the score vector), we add an inequality between the corresponding indicator variables inside the ILP.4 As we increase the value of a
For the ith dimension of the score vector, we choose either i or i as the threshold. 4 If the constraints dictated by any two dimensions of S are contradictory, we ignore both of them.
3

