We give here a proof of the correctness of the algorithm. We use the fact that the ZDD is constructed recursively; given the i-th branch node zi of a ZDD, the subgraph induced by the set of nodes that are descendants of zi is also a ZDD. Let the ZDD whose root node is zi be Zi , and the family of sets represented by Zi be Ti . Family of sets Ti , Tlo(i) and Thi(i) satisfy the following relationship. Ti = Tlo(i)  {ev(i)  T |T  Thi(i) } Proposition 1. Alg. 1 can find the optimal solution of the problem of Eq.(1), where we assume T is represented as an ordered ZDD. Proof. We use induction to give a proof that S [i][j ] = maxT ei T wi after running our algorithm, where T is a set of tree nodes that satisfies T  Ti and ei T li = j . If i = |Z | - 1, then Ti = {} and S [i][0] = 0 and S [i][j ] = - for j = 0, which satisfies the condition. Suppose that S [lo(i)][j ] and S [hi(i)][j ] both satisfy the condition for j = 0, . . . , L. If the set that maximizes S [i][j ] does not have ev(i) , then the set is contained in Tlo(i) , and its size is j . Therefore, the maximum weight equals S [lo(i)][j ] (Alg.1 line 9). Otherwise, the set that maximizes S [i][j ] has ev(i) , so the item is contained in {ev(i)  T |T  Thi(i) }, and its weight is S [hi(i)][j -lv(i) ]+wv(i) (Alg.1 line 6). Since Z1 corresponds to the root node and it represents all possible solutions, maxj S [1][j ] is the maximum weight of the subset that satisfies the length limit and is contained in T . Proposition 2. The time and space complexity of Alg. 1 are both O(|Z |L). Proof. We have to store tables S, B and solution r. The tables have |Z | × (L + 1) entries and |Z |  |r|, the space complexity is O(|Z |L). For the time complexity, filling entries in S and B requires O(|Z |L) time since to fill an entry requires constant time. Backtracking requires at most N updates, hence the time complexity is O(|Z |L). We show an example of our algorithm in Fig. 2. Suppose that D = {e1 e2 , e1 e3 , e2 e3 }, (l1 , l2 , l3 ) = (1, 1, 3) and (w1 , w2 , w3 ) = (2, 1, 3). Set D is represented as the ZDD in Fig. 2(a). Let L = 4 and run the DP algorithm yielding tables S and B shown in 466
(a) (b) (c)

Figure 3: Example ZDDs representing the set of trimmed subtrees of the trees in Fig. 1. (a) Rootedtree, (b) multi-rooted tree, and (c) nested-tree Fig. 2(b,c). Suppose that we want to fill entry S [1][4] (the upper right cell). There are two possible paths to reach the entry; the first path takes the high-edge from S [2][3], and the second path takes the low-edge from S [3][4]. We use hollow and black arrows to represent these paths in Fig. 2(b). Since the former path results in weight 5, which is higher than that of the later path, hence we set S [1][4] = 5 and B [1][4] = HI. After filling all the entries in tables, we can see S [1][4] has the maximum weight, and the backtracking from B [1][4]  B [2][3]  B [4][3]  B [5][0]. B [5][0] corresponds to the terminal node, and the backtracking yields the optimal solution e1 e3 .

5

ZDD Sizes

We give upper bounds on the size of the ZDD representing the family of sets T of Eq.(1) for the three problems. The number of subtrees contained in T may grow exponentially with the size of the original tree, however, we can represent them as a ZDD with very few nodes. Since the running time of our algorithm is O(|Z |L), these theoretical upper bounds determine the running time of the proposed tree trimming algorithms. We first give a proof of the size of the ZDD that represents all rooted subtrees of a given tree. Proposition 3. Given a tree with N nodes, we can construct a ZDD that represents all rooted subtrees of the tree whose number of nodes is N + 2, if we use a depth first pre-order of tree nodes as the order

