Initial configuration: Further calls: Scan:

0, , { : S }

Initial call:

0, , { : S } 0, 1, { : S , 1 : S } Predict: i, p, S  p : A i, p, S  p : 0,0
A  N, A  1,0  

i, p, S  p : k,i i, pj, S  p : k,i  pj : A
wj +1

k,i  [k,i ]A  , A  N,  (k,i ) = j + 1

j, p, S  p : k,i j + 1, p, S  p : k,i+1

k,i  k,i+1  

Publish:

i, p, S  {p : k,i } i, p, S  {p : ret }

k,j  ret  

Suspend 1: Suspend 2: Resume:

i, pj, S  {p : k,i , pj : ret } i, p, S  {p : k,i+1 } i, pj, S  {p : k,i , pj : l,m } i, p, S  {p : k,i+1 , pj : l,m }

[k,i ]ret  k,i+1   [k,i ]l,m  k,i+1 [l,m ]   k,i [l,j ]  [k,i ]l+1,0  

i, p, S  {p : k,i , p (k,i ) : l,j } i, p (k,i ), S  {p : k,i , p (k,i ) : l+1,0 }

Figure 3: Deduction rules for TA configurations

stack, a set of completed components and the remaining input. The completed components are of the form p : i where p is an address and i the component of a rule. The stack has the form 1 x1 2 . . . xn-1 n where i is an address followed by a state and xi  T  {Ak | A  N, 1  k  dim (A)}. Shift: Whenever we have p : q on top of the stack and an edge from q to q labeled with the next input symbol and an address p , we add the input symbol followed by pp : q to the stack. Suspend: Whenever the top of the stack is p1 : q such that there is a i-1,k  q with k = |lhs (, i - 1)| and i < dim ( ), we can suspend. If i = 1, we add p1 : i to the set of completed components and we remove |lhs (, i)| terminals/component nonterminals and their preceding states from the stack. If i  1, we check whether there is a p2 : i-1 in the set of completed components such that the intersection L(p1 )  L(p2 ) is not empty.2 We then remove p2 : i-1 from the set of complete components and we add p : i to it where p is a regular expression denoting L(p1 )  L(p2 ). Suppose the topmost state on the stack is now p : q . We then have to follow the edge leading from q to some q labeled Ai : p where A = lhs ( ). This means that we push Ai followed by p p : q on the stack.
2 Note that the corresponding finite state automata can be deterministic; in this case the intersection is quadratic in the size of the two automata. In LCFRS without left recursion in any of the components, the intersection is trivial since the regular expressions denote only a single path each.

Reduce: Whenever there is a i-1,k in our current state with k = |lhs (, i - 1)| and i = dim ( ), we can reduce, which is like suspend except that nothing is added to the set of completed components. 3.2 Automaton and parse table construction The states of the LR-automaton are sets of pairs p : X where p is a regular expression over {1, . . . , m}, m the rank of G, and X  C  {S }. They represent predict and resume closures.The predict/resume closure q of some set q is described by the deduction rules in figure 4. This closure is not always finite. :S 1 : 0,0
lhs () = S

p : i,j pk : l,0

lhs (, i, j ) = rhs (, k - 1, l), rhs (, k) = lhs ( )

Figure 4: Predict/resume closure

However, if it is not, we obtain a set of items that can be represented by a finite set of pairs r : i,j plus eventually  : S such that r is a regular expression denoting a set of possible addresses. As an example for such a case, see q3 in figure 5. The reason why we can represent these closures by finite sets using regular expressions for paths is the following: There is a finite number of possible elements i,j . For each of these, the set of possible addresses it might be combined with in a state that is the closure of { : X1 ,  : X2 , . . . ,  : Xn } is generated by the CFG C{S } {Snew }, {1, . . . , m}, P, Snew with Snew  Xi  P for all 1  i  n, X  Y k  P for all in-

1253

